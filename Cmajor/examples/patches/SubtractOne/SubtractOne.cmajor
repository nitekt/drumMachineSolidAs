/*
    This file was auto-generated by the cmaj tool!
    cmajor.dev
*/

graph Voice [[ main ]]
{
    input event std::midi::Message midiIn;

    input event float32 power            [[ name: "Power", init: 1.0, boolean]];

    input event float32 masterGain       [[ name: "Master Gain",    min: 0,  max: 1,  init: 1.0,   step: 0.01 ]];
    input event float32 masterOctave     [[ name: "Master Octave",  min: -3, max: 3,  init: 0,     step: 1 ]];
    input event float32 masterGlide      [[ name: "Master Glide",   min: 0,  max: 3,  init: 0,     step: 0.01 ]];

    input event float32 vco1Semitones    [[ name: "VCO1 Semitones",  min: -24, max: 24,  init: 0,   step: 1 ]];
    input event float32 vco1Detune       [[ name: "VCO1 Detune",     min: -50, max: 50,  init: 0,   step: 1 ]];
    input event float32 vco1Level        [[ name: "VCO1 Level",      min: 0,   max: 1,   init: 1,   step: 0.001 ]];
    input event float32 vco1Shape        [[ name: "VCO1 Shape",      min: 0,   max: 4,   init: 3,   text: "Sine|Triangle|Square|Ramp Up|Ramp Down"]];

    input event float32 vco2Semitones    [[ name: "VCO2 Semitones",  min: -24, max: 24,  init: 0,   step: 1 ]];
    input event float32 vco2Detune       [[ name: "VCO2 Detune",     min: -50, max: 50,  init: 0,   step: 1 ]];
    input event float32 vco2Level        [[ name: "VCO2 Level",      min: 0,   max: 1,   init: 0,   step: 0.001 ]];
    input event float32 vco2Shape        [[ name: "VCO2 Shape",      min: 0,   max: 4,   init: 3,   text: "Sine|Triangle|Square|Ramp Up|Ramp Down"]];

    input event float32 vco3Semitones    [[ name: "VCO3 Semitones",  min: -24, max: 24,  init: 0,   step: 1 ]];
    input event float32 vco3Detune       [[ name: "VCO3 Detune",     min: -50, max: 50,  init: 0,   step: 1 ]];
    input event float32 vco3Level        [[ name: "VCO3 Level",      min: 0,   max: 1,   init: 0,   step: 0.001 ]];
    input event float32 vco3Shape        [[ name: "VCO3 Shape",      min: 0,   max: 4,   init: 3,   text: "Sine|Triangle|Square|Ramp Up|Ramp Down"]];

    input event float32 filterCutoff     [[ name: "Filter Cutoff",    min: 100,  max: 20000, init: 1500, step: 1 ]];
    input event float32 filterResonance  [[ name: "Filter Resonance", min: 0,    max: 100,   init: 1,    step: 1 ]];
    input event float32 filterEgInt      [[ name: "Filter Eg Int",    min: -100, max: 100,   init: 50,   step: 1 ]];

    input event float32 ampEgAttack      [[ name: "AmpEg Attack",  min: 0, max: 10,  init: 0.1,   step: 0.01 ]];
    input event float32 ampEgDecay       [[ name: "AmpEg Decay",   min: 0, max: 10,  init: 1.0,   step: 0.01 ]];
    input event float32 ampEgSustain     [[ name: "AmpEg Sustain", min: 0, max: 100, init: 100.0, step: 1 ]];
    input event float32 ampEgRelease     [[ name: "AmpEg Release", min: 0, max: 10,  init: 2.0,   step: 0.01 ]];

    input event float32 filterEgAttack   [[ name: "FilterEg Attack",  min: 0, max: 10,  init: 0.1,   step: 0.01 ]];
    input event float32 filterEgDecay    [[ name: "FilterEg Decay",   min: 0, max: 10,  init: 1.0,   step: 0.01 ]];
    input event float32 filterEgSustain  [[ name: "FilterEg Sustain", min: 0, max: 100, init: 100.0, step: 1 ]];
    input event float32 filterEgRelease  [[ name: "FilterEg Release", min: 0, max: 10,  init: 2.0,   step: 0.01 ]];

    output stream float out;
    output snapshotGenerator.snapshot;

    node frequencyGenerator = FrequencyGenerator;
    node amplitudeEnvelope  = EnvelopeGenerator;
    node filterEnvelope     = EnvelopeGenerator;
    node filter             = std::filters::tpt::svf::Processor;
    node filterScaler       = FilterParameterScaler;
    node osc1 = Oscillator;
    node osc2 = Oscillator;
    node osc3 = Oscillator;
    node gain = Gain;
    node powerGain = std::smoothing::SmoothedValueStream (0.02f);
    node snapshotGenerator = SnapshotGenerator;

    connection
    {
        midiIn -> std::midi::MPEConverter -> EventProcessor -> frequencyGenerator.eventIn,
                                                               amplitudeEnvelope.eventIn,
                                                               filterEnvelope.eventIn;

        masterGlide  -> frequencyGenerator.glideIn;

        filterCutoff       -> filterScaler.frequencyIn;
        filterEgInt        -> filterScaler.intIn;
        filterEnvelope.out -> filterScaler.envelopeIn;
        filterResonance    -> filterScaler.resonanceIn;

        filterScaler.frequencyOut -> filter.frequency;
        filterScaler.resonanceOut -> filter.q;

        ampEgAttack  -> amplitudeEnvelope.attack;
        ampEgDecay   -> amplitudeEnvelope.decay;
        ampEgSustain -> amplitudeEnvelope.sustain;
        ampEgRelease -> amplitudeEnvelope.release;

        filterEgAttack  -> filterEnvelope.attack;
        filterEgDecay   -> filterEnvelope.decay;
        filterEgSustain -> filterEnvelope.sustain;
        filterEgRelease -> filterEnvelope.release;

        vco1Semitones   -> osc1.semitonesIn;
        vco1Detune      -> osc1.detuneIn;
        vco1Level       -> osc1.levelIn;
        vco1Shape       -> osc1.shapeIn;
        masterOctave    -> osc1.octaveIn;

        vco2Semitones   -> osc2.semitonesIn;
        vco2Detune      -> osc2.detuneIn;
        vco2Level       -> osc2.levelIn;
        vco2Shape       -> osc2.shapeIn;
        masterOctave    -> osc2.octaveIn;

        vco3Semitones   -> osc3.semitonesIn;
        vco3Detune      -> osc3.detuneIn;
        vco3Level       -> osc3.levelIn;
        vco3Shape       -> osc3.shapeIn;
        masterOctave    -> osc3.octaveIn;

        frequencyGenerator.note -> osc1.noteIn, osc2.noteIn, osc3.noteIn;

        (amplitudeEnvelope.out * (osc1.out + osc2.out + osc3.out)) -> gain.in;
        power -> powerGain;
        masterGain -> gain.level;
        powerGain.out * gain.out -> filter.in;
        filter.out -> out, snapshotGenerator.in;
    }
}

processor EventProcessor
{
    input event (std::notes::NoteOn, std::notes::NoteOff) eventIn;
    output event (std::notes::NoteOn, std::notes::NoteOff) eventOut;

    event eventIn (std::notes::NoteOn n)
    {
        notes[head] = n;
        head++;
        activeNotes++;
        eventOut <- n;
    }

    event eventIn (std::notes::NoteOff n)
    {
        {
            wrap<bufferSize> source;
            wrap<bufferSize> target;

            loop (int (head))
            {
                if (notes[source].pitch != n.pitch)
                {
                    notes[target] = notes[source];
                    target++;
                }
                else
                {
                    activeNotes--;
                }

                source++;
            }

            head = target;
        }

        if (activeNotes != 0)
            eventOut <- notes.at (head-1);
        else
            eventOut <- n;
    }

    let bufferSize = 10;

    std::notes::NoteOn[bufferSize] notes;
    wrap<bufferSize> head;
    var activeNotes = 0;
}

processor SnapshotGenerator
{
    input stream float in;
    output event float[snapshotLength] snapshot;

    let snapshotLength = 992;
    let snapshotRate = 30.0f;

    void main()
    {
        var framesPerSnapshot = int (processor.frequency / snapshotRate);

        loop
        {
            float[snapshotLength] buffer;

            wrap<snapshotLength> i;
            loop (snapshotLength)
            {
                buffer[i++] = in;
                advance();
            }

            snapshot <- buffer;

            loop (framesPerSnapshot - snapshotLength)
                advance();
        }
    }
}

processor FilterParameterScaler
{
    input stream float32 envelopeIn;
    input event float32 intIn;
    input event float32 frequencyIn;
    input event float32 resonanceIn;

    output event float32 frequencyOut;
    output event float32 resonanceOut;

    event resonanceIn (float f)     { resonanceOut <- 0.5f + (f * 0.05f); }
    event intIn (float f)           { intensity = f; }
    event frequencyIn (float f)     { cutoff = f; }

    float cutoff, intensity;

    void main()
    {
        loop
        {
            let f = cutoff + (envelopeIn * intensity * 50.0f);
            frequencyOut <- max (f, 100.0f);

            advance();
        }
    }

}

graph Oscillator
{
    input event float32 octaveIn, noteIn, semitonesIn, detuneIn;
    input event float32 levelIn;
    input event float32 shapeIn;

    output stream float out;

    node osc                = std::oscillators::PolyblepOscillator (float32, std::oscillators::Shape::sine);
    node frequencyProcessor = FrequencyProcessor;
    node gain               = Gain (1.0f);

    connection
    {
        octaveIn -> frequencyProcessor.octaveIn;
        noteIn -> frequencyProcessor.noteIn;
        semitonesIn -> frequencyProcessor.semitonesIn;
        detuneIn    -> frequencyProcessor.detuneIn;

        frequencyProcessor.frequencyOut -> osc.frequencyIn;
        shapeIn                         -> osc.shapeIn;

        osc.out -> gain.in;
        levelIn -> gain.level;

        gain.out -> out;
    }
}

processor Gain (float32 scalingFactor = 1.0f, float32 smoothingTimeSeconds = 0.02f)
{
    input stream float32 in;
    input event float32 level;

    output stream float32 out;

    event level (float32 newTarget)
    {
        smoothedValue.setTarget (newTarget, max (1, int32 (smoothingTimeSeconds / float32 (processor.period))));
    }

    void main()
    {
        loop
        {
            out <- in * smoothedValue.getNext() * scalingFactor;
            advance();
        }
    }

    std::smoothing::SmoothedValue smoothedValue;
}

processor FrequencyProcessor
{
    input event float32 noteIn, semitonesIn, detuneIn, octaveIn;
    output event float32 frequencyOut;


    event octaveIn (float f)        { octave = f * 12.0f;   frequencyOut <- std::notes::noteToFrequency (octave + note + semitones + detune); }
    event noteIn (float f)          { note = f;             frequencyOut <- std::notes::noteToFrequency (octave + note + semitones + detune); }
    event semitonesIn (float f)     { semitones = f;        frequencyOut <- std::notes::noteToFrequency (octave + note + semitones + detune); }
    event detuneIn (float f)        { detune = f * 0.01f;   frequencyOut <- std::notes::noteToFrequency (octave + note + semitones + detune); }

    float octave, note, semitones, detune;
}

processor FrequencyGenerator
{
    input event std::notes::NoteOn eventIn;
    input event float glideIn;

    output event float32 note;

    event glideIn (float e)
    {
        glideSeconds = e;
    }

    event eventIn (std::notes::NoteOn e)
    {
        targetNote = e.pitch;
        framesToApplyIncrement = (glideSeconds > 0) ? int (processor.frequency * glideSeconds) : 1;
        noteIncrement = (targetNote - currentNote) / framesToApplyIncrement;
    }

    float glideSeconds = 0.0f;

    float currentNote;
    float targetNote;
    float noteIncrement;
    int   framesToApplyIncrement;

    void main()
    {
        note <- currentNote;

        loop
        {
            if (framesToApplyIncrement > 0)
            {
                currentNote += noteIncrement;
                framesToApplyIncrement--;
                note <- currentNote;
            }

            advance();
        }
    }
}

processor EnvelopeGenerator
{
    input event (std::notes::NoteOn, std::notes::NoteOff) eventIn;
    input event float attack;
    input event float decay;
    input event float sustain;
    input event float release;

    output stream float32 out;

    event eventIn (std::notes::NoteOn e)    { noteReceived = true; triggered = true; }
    event eventIn (std::notes::NoteOff e)   { triggered = false; }

    event attack (float seconds)            { attackRamp = 1.0 / (processor.frequency * max (minTime, seconds)); }
    event decay (float seconds)             { decayMultiplier = pow (0.0001, 1.0 / (processor.frequency * max (minTime, seconds))); }
    event sustain (float levelPercent)      { sustainLevel = levelPercent * 0.01; }
    event release (float seconds)           { releaseMultiplier = pow (0.0001, 1.0 / (processor.frequency * max (minTime, seconds))); }

    float32 minTime = 0.001f;

    float64 attackRamp = 0.01;
    float64 decayMultiplier = 0.99;
    float64 sustainLevel = 1;
    float64 releaseMultiplier = 0.999;

    bool noteReceived = false;
    bool triggered = false;

    void main()
    {
        float64 currentValue;

        loop
        {
            if (noteReceived)
            {
                noteReceived = false;

                // Attack
                while (currentValue < 1.0 && triggered && ! noteReceived)
                {
                    currentValue = min (currentValue + attackRamp, 1.0);
                    out <- float (currentValue);
                    advance();
                }

                // Decay
                while (currentValue >= sustainLevel && triggered && ! noteReceived)
                {
                    currentValue *= decayMultiplier;
                    out <- float (currentValue);
                    advance();
                }

                // Sustain
                while (triggered && ! noteReceived)
                {
                    out <- float (currentValue);
                    advance();
                }
            }

            // Release
            currentValue *= releaseMultiplier;
            out <- float (currentValue);
            advance();
        }
    }
}
