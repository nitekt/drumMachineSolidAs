
/*
    This file was auto-generated by the cmaj VScode extension!
    https://cmajor.dev
*/
//./cmaj generate --target=webaudio --output=./solidjs_sound/cmaj_SDM_engine.js SDM_engine.cmajorpatch
// run this to auto-rebuild cmajor patch
// Here's a very simple graph that plays a sine-wave to get you started..
namespace engine {
    const float min = -100;
    const float max = 6;
    
    int sign(float e) {
        if (e > 0) {
            return 1;
        } else if (e < 0) {
            return -1;
        } else {
            return 0;
        }
    }
    graph SDM_engine  [[ main ]]
    {
        // stuff goes in here
        output stream float out;

        input event bool pressed [[ name: "trig", boolean: true, init: false]];
        input event int id_ [[ name: "voice", min: 0, max: 5, init: 0, step: 1]];
        input event float volume [[name: "volume gain", min: -100, max: 6, init: -4]];
        const int numVoices = 6;
        node voice = Voice[numVoices];
        
        
        node selecta = Selecta(numVoices); //sendsevents  to the correct voices (engines)
            
        connection {
            pressed -> selecta.in_trig; //ins
            id_ -> selecta.id;
            volume -> selecta.t_volume_in;

            selecta.out_trig -> voice.trig; //outs
            selecta.freq -> voice.freq;
            selecta.t_volume_out -> voice.volume;
            
            voice.out -> out;
        }
        

    }
    processor Selecta(const int numVoices) {
        output event bool out_trig[numVoices];
        output event float freq[numVoices];
        output event float t_volume_out[numVoices];

        input event bool in_trig;
        input event int id;
        input event float t_volume_in; //track volume
        int id_;
        void main() {
            
            //id_ = id;
            
            // freq[0] <- 300.0f;
            // freq[1] <- 510.0f;
            for(int j = 0; j < numVoices; j++) {
                freq[wrap<numVoices> (j)] <- 300.0f + (j*30.0f);
            }
            advance();
            //console <- id <- "hi your mum";
        }
        event id (int e) {
            id_ = e;
            // console <- id_ <- "hi your mum";
        }
        event t_volume_in (float e) {
            
            float norm = (e - min) / (max-min); //normalize between 0-1
            // float scaled = log(1.0f-norm);
            float scaled = pow(norm, 0.57f);
            float remapped = std::levels::gainTodB(scaled);
            console <- "remapped is: " <- remapped;
            // float remapped = min + norm * (max-min);
            t_volume_out[wrap<numVoices> (id_)] <- remapped;
        }
        event in_trig (bool e) {
            if (e) {
                
                out_trig[wrap<numVoices> (id_)] <- e; //id_
                
                // freq[0] <- 400.0f;
                
            }
    
        }
        
        
    }
    graph Voice { //the drum machine device on each track
        // stuff goes in here
        output stream float out;

        input event bool trig; 
        input event float freq;
        // input event float volume;
        input event float volume;
        node sine = std::oscillators::Sine(float, 300);
        node gain = std::levels::SmoothedGain(float, 0.05f);
        
        node envelope = env;
        
        connection {
            volume -> gain.volume;
            freq -> sine.frequencyIn;
            trig -> envelope.pressed;

            sine -> envelope.in;
            // envelope.out * volume -> out;
            envelope.out -> gain.in;
            gain.out -> out;
        }
    }



    processor env {
        output stream float out;
        input stream float in;
        input event bool pressed;
        
        int on = 0;
        int sampleRate = 44100;
        int timer = sampleRate; // 1 second hopefully
        float level = 0.7f;
        float start = level;
        float end = 0.0f;
        //input value int on;
        event pressed (bool e) {
            if(e) {
                on = 1;
                level = 0.7f;
                timer = sampleRate/10;
                //console <- "this one g" <- on;
            }
        }
        
        float ramp(float start, float end, float duration) {
            return (end - start) / (duration * sampleRate);
        }
        void main() {
            var step = ramp(level, end, 0.2f); //get step size
            loop {
                if(on == 1) {

                    if (timer > 1) {
                        timer = timer - 1;
                    } else {
                        if ((start < end && level < end) || (start > end && level > end)) {

                            level += step;  // Apply ramp step
                        } else {
                            on = 0;
                        }
                        
                    }
                }
                out <- in * (level * on);
                advance();

            }
            
        }
    }
}


